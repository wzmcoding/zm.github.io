---
title: diff
date: 2025-07-20
updated: 2025-07-20
categories: 手写Vue3源码
tags:
  - diff
top: 1
---

# diff
## 全量 diff （重要）
全量 diff 主要是针对两个子节点都是数组的情况，我们需要对它所有的子元素进行全量更新，那么这种更新非常消耗性能，
在 vue 中会尝试着尽可能的复用 dom，来进行更新，我们来看这么几种情况

## 双端 diff
### 头部对比
我们先来看一下头部对比的场景，我们假设子节点是通过 `v-for` 渲染出来的，最开始数组为 `[a, b]`，然后我们 `push` 了一个 `c` 进去：
- `c1 = [a, b]`
- `c2 = [a, b, c]`
  此时我们只需要从头开始进行对比就可以，`c1` 的第一个为 `a`，`c2` 的第一个也是 `a`，他们的 `key` 都是可以对应的上的，
  所以依次对比 `a` 和 `b`，到 `c` 之后，发现 `c1` 里面没有 `c`，那就直接挂载新的子节点就可以了
实现代码：
```typescript
// 开始对比的下标
let i = 0

// 老的子节点的最后一个元素的下标
let e1 = c1.length - 1

// 新的子节点的最后一个元素的下标
let e2 = c2.length - 1

/**
 * * 1.1 头部对比
 * c1 => [a, b]
 * c2 => [a, b, c]
 *
 * 开始时：i = 0, e1 = 1, e2 = 2
 * 结束时：i = 2, e1 = 1, e2 = 2
 *
 */
while (i <= e1 && i <= e2) {
  const n1 = c1[i]
  const n2 = c2[i]

  if (isSameVNodeType(n1, n2)) {
    // 如果 n1 和 n2 是同一个类型的子节点，那就可以更新，更新完了，对比下一个
    patch(n1, n2, container)
  } else {
    break
  }

  i++
}
```
### 尾部对比
当然，我们这里只是列出了头部对比，但是实际工作中，我们不一定只是向尾部添加元素，还有可能往头部添加，比如 `unshift`，那么接下来我们往头部添加一个子节点 `c`：
- `c1 = [a, b]`
- `c2 = [c, a, b]`
  此时很明显头部对比就对比不上了，因为 `c1` 的第一项是 `a`，`c2` 的第一项是 `c`，那么在头部对比的代码中第一次就会被 `break`，
  但是我们会发现，头部虽然对比不上，但是尾部是可以对比的上的，比如 `c1` 的最后一项是 `b`，`c2` 的最后一项也是 `b`，那么我们是不是可以倒着比
实现代码：
```typescript
// 开始对比的下标
let i = 0

// 老的子节点的最后一个元素的下标
let e1 = c1.length - 1

// 新的子节点的最后一个元素的下标
let e2 = c2.length - 1

/* 省略头部对比的代码 */

/**
 * * 1.2 尾部对比
 *
 * c1 => [a, b]
 * c2 => [c, d, a, b]
 * 开始时：i = 0, e1 = 1, e2 = 3
 * 结束时：i = 0，e1 = -1, e2 = 1
 */
while (i <= e1 && i <= e2) {
  const n1 = c1[e1]
  const n2 = c2[e2]

  if (isSameVNodeType(n1, n2)) {
    // 如果 n1 和 n2 是同一个类型的子节点，那就可以更新，更新完了之后，对比上一个
    patch(n1, n2, container)
  } else {
    break
  }

  // 更新尾指针
  e1--
  e2--
}
```
### 结论
当双端 `diff` 完成后，我们可以得出以下结论，当 `i > e1` 的时候，表示新的子节点多，老的子节点少，
所以我们需要插入新的子节点，插入的范围为 `i - e2`，反之当 `i > e2` 的时候，
表示老的多，新的少，需要将老的子节点中多余的卸载掉，代码实现如下：
```typescript
if (i > e1) {
  /**
   * 根据双端对比，得出结论：
   * i > e1 表示老的少，新的多，要挂载新的，挂载的范围是 i - e2
   */
  const nextPos = e2 + 1
  // 由于挂载不一定是追加到父元素的最后面，所以此处需要获取到 anchor，插入到某个元素之前
  const anchor = nextPos < c2.length ? c2[nextPos].el : null
  console.log(anchor)
  while (i <= e2) {
    patch(null, c2[i], container, anchor)
    i++
  }
} else if (i > e2) {
  /**
   * 根据双端对比，得出结果：
   * i > e2 的情况下，表示老的多，新的少，要把老的里面多余的卸载掉，卸载的范围是 i - e1
   */ while (i <= e1) {
    unmount(c1[i])
    i++
  }
}
```
在此处，我们获取到了 `anchor` ，是因为我们每次更新不一定是要插入到元素的最后面，比如：
- `c1 = [a, b]`
- `c2 = [c, a, b]`
  在这种情况下，`c` 肯定是要插入到 `a` 之前，所以我们要想办法拿到 `a`，当对比结束后，`e1` 应该是等于 `c` 的索引，
  那么 `a` 的索引应该为 `e2 + 1`，我们通过索引拿到 `anchor`，将它传递给 `patch`，
  从 `patch` 到 `mountElement` 之间所有的调用将传递 `anchor`，不再一一展示


## 乱序 diff

