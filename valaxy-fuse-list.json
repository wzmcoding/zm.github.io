[{"title":"","tags":[],"categories":[],"author":"前端练习生zm","excerpt":"","link":"/404"},{"title":"关于我","tags":[],"categories":[],"author":"前端练习生zm","excerpt":"前端练习生一枚。\n","link":"/about"},{"title":"关于站点","tags":[],"categories":[],"author":"前端练习生zm","excerpt":"记录生活与成长。\n","link":"/about/site"},{"title":"","tags":[],"categories":[],"author":"前端练习生zm","excerpt":"","link":"/archives"},{"title":"","tags":[],"categories":[],"author":"前端练习生zm","excerpt":"","link":"/categories"},{"title":"gitee","tags":[],"categories":[],"author":"前端练习生zm","excerpt":"\n[gitee地址](https://gitee.com/wzm_love_coding)\n","link":"/links"},{"title":"","tags":[],"categories":[],"author":"前端练习生zm","excerpt":"","link":"/tags"},{"title":"编译时 —— compiler-core","tags":["手写Vue3源码之编译时"],"categories":["手写Vue3源码之编译时"],"author":"前端练习生zm","excerpt":"\n## **编译时 —— compiler-core**\n\n## 什么是编译时？\n\n将模板编译成 js 的过程，就是编译时\n\n```vue\n<div>111</div>\n```\n\n把上面这一坨当做一个","link":"/posts/compiler"},{"title":"组件挂载","tags":["手写Vue3源码之组件篇"],"categories":["手写Vue3源码之组件篇"],"author":"前端练习生zm","excerpt":"\n# 组件挂载\n使用方式:\n```javascript\nimport { h, ref, createApp } from '../dist/vue.esm.js'\nconst Comp = {\n  ","link":"/posts/component"},{"title":"ref 和 expose","tags":["手写Vue3源码之组件篇"],"categories":["手写Vue3源码之组件篇"],"author":"前端练习生zm","excerpt":"\n## ref 和 expose\n- expose\n我们先来实现一下 `expose`，之前我们完成了 `attrs`、`emit` 和 `slots`，所以我们直接在原来的 `createSetup","link":"/posts/component10"},{"title":"provide 和 inject","tags":["手写Vue3源码之组件篇"],"categories":["手写Vue3源码之组件篇"],"author":"前端练习生zm","excerpt":"\n## provide 和 inject\n- `provide` 和 `inject` 允许祖先组件向其所有子孙后代组件注入一个依赖，而不管组件层级有多深。我们一般会用它来进行祖先组件和后代组件之间的","link":"/posts/component11"},{"title":"函数式组件实现原理","tags":["手写Vue3源码之组件篇"],"categories":["手写Vue3源码之组件篇"],"author":"前端练习生zm","excerpt":"\n## 函数式组件实现原理\n函数式组件（Functional Component）是 Vue 中一种特殊的组件类型，它是一个纯函数，接收 `props` 作为参数并返回 `VNode`。本文将深入分析","link":"/posts/component12"},{"title":"Teleport 组件实现原理","tags":["手写Vue3源码之组件篇"],"categories":["手写Vue3源码之组件篇"],"author":"前端练习生zm","excerpt":"\n## Teleport 组件实现原理\nTeleport 是 Vue3 中一个非常实用的内置组件，它可以将组件的内容渲染到 DOM 树的任何位置。\n\n## 1. 基本概念\n\nTeleport 组件主要","link":"/posts/component13"},{"title":"KeepAlive 组件实现原理","tags":["手写Vue3源码之组件篇"],"categories":["手写Vue3源码之组件篇"],"author":"前端练习生zm","excerpt":"\n## KeepAlive 组件实现原理\nKeepAlive 是 Vue3 中一个内置组件，用于缓存组件实例和 DOM，以提高组件切换的性能。本文将深入分析 KeepAlive 组件的实现原理。\n\n#","link":"/posts/component14"},{"title":"Transition 组件实现原理","tags":["手写Vue3源码之组件篇"],"categories":["手写Vue3源码之组件篇"],"author":"前端练习生zm","excerpt":"\n## Transition 组件实现原理\nTransition 是 Vue3 中的内置组件，用于在元素或组件进入和离开 DOM 时添加过渡动画效果。本文将深入分析 Transition 组件的实现原","link":"/posts/component15"},{"title":"defineAsyncComponent 实现原理","tags":["手写Vue3源码之组件篇"],"categories":["手写Vue3源码之组件篇"],"author":"前端练习生zm","excerpt":"\n## defineAsyncComponent 实现原理\n`defineAsyncComponent` 是 Vue3 中用于定义异步组件的 API，它能够优雅地处理组件的异步加载、加载状态显示和错误","link":"/posts/component16"},{"title":"PatchFlags","tags":["手写Vue3源码之组件篇"],"categories":["手写Vue3源码之组件篇"],"author":"前端练习生zm","excerpt":"\n## PatchFlags\n什么是 PatchFlags？\nPatchFlags 是 Vue 3 中用于优化虚拟 DOM 更新的一种机制。\n它们是编译器在编译模板时生成的标志，用于指示哪些部分的虚拟","link":"/posts/component17"},{"title":"属性传递（props和attrs）","tags":["手写Vue3源码之组件篇"],"categories":["手写Vue3源码之组件篇"],"author":"前端练习生zm","excerpt":"\n# 属性传递（props和attrs）\nprops和attrs的区别：是否在组件中声明属性，声明了就是props，没有声明就是attrs\n```javascript\nconst Comp = {\n ","link":"/posts/component2"},{"title":"组件的代理对象","tags":["手写Vue3源码之组件篇"],"categories":["手写Vue3源码之组件篇"],"author":"前端练习生zm","excerpt":"\n## 组件的代理对象\n我们在组件中使用 `this` 可以访问到 `setupState、props、attrs、slots、$refs` 等属性，这些属性都是通过代理对象实现的。\n组件的代理对象实","link":"/posts/component3"},{"title":"组件的异步更新","tags":["手写Vue3源码之组件篇"],"categories":["手写Vue3源码之组件篇"],"author":"前端练习生zm","excerpt":"\n## 组件的异步更新\n先看案例\n```javascript\nimport { h, ref, createApp } from '../dist/vue.esm.js'\n\nconst Comp = ","link":"/posts/component4"},{"title":"组件的属性更新","tags":["手写Vue3源码之组件篇"],"categories":["手写Vue3源码之组件篇"],"author":"前端练习生zm","excerpt":"\n## 组件的属性更新\n先看案例：\n```javascript\nconst Child = {\n  // 接受了父组件传递的 age\n  props: ['age'],\n  setup(props) ","link":"/posts/component5"},{"title":"绑定组件的事件","tags":["手写Vue3源码之组件篇"],"categories":["手写Vue3源码之组件篇"],"author":"前端练习生zm","excerpt":"\n## 绑定组件的事件\n先看下平时使用的事件绑定方式：\n```javascript\nconst Child = {\n  setup(props, { emit }) {\n    return () =","link":"/posts/component6"},{"title":"组件的插槽","tags":["手写Vue3源码之组件篇"],"categories":["手写Vue3源码之组件篇"],"author":"前端练习生zm","excerpt":"\n## 组件的插槽\n先看使用案例:\n```javascript\n// 父组件\nconst Comp = {\n  setup() {\n    return () => {\n      return h(","link":"/posts/component7"},{"title":"获取组件的实例","tags":["手写Vue3源码之组件篇"],"categories":["手写Vue3源码之组件篇"],"author":"前端练习生zm","excerpt":"\n## 获取组件的实例\n我们在组件中，一般会通过 `getCurrentInstance` 来获取当前组件的实例，这个 API 主要是为了在 `setup` 函数中获取当前组件的实例。\n```java","link":"/posts/component8"},{"title":"组件的生命周期","tags":["手写Vue3源码之组件篇"],"categories":["手写Vue3源码之组件篇"],"author":"前端练习生zm","excerpt":"\n## 组件的生命周期\n\n## 生命周期的使用\n- 在组件 setup 内使用以下 API 注册生命周期：\n  - onBeforeMount(fn)：在组件挂载之前调用\n  - onMounted(","link":"/posts/component9"},{"title":"手写 computed","tags":["手写Vue3源码"],"categories":["手写Vue3源码"],"author":"前端练习生zm","excerpt":"\n### computed 实现原理\n#### 1. computed 的双重身份\n`computed` 计算属性有一个非常独特的设计 - 它同时具备两个身份：\n1. 作为依赖项（Dep）: 可以被其","link":"/posts/computed"},{"title":"createApp","tags":["createApp"],"categories":["手写Vue3源码"],"author":"前端练习生zm","excerpt":"\n# createApp\n平时如何使用：\n```typescript\nimport { h, ref, createApp } from '../dist/vue.esm.js'\n// 创建一个组件\n","link":"/posts/create-app"},{"title":"WebStorm 如何调试 Vue 项目","tags":["work-summary"],"categories":["work-summary"],"author":"前端练习生zm","excerpt":"\n### 调试前准备\n1. 确保 WebStorm 已安装 `JavaScript Debugger`插件。一般情况下，WebStorm 默认已安装此插件。\n2. 修改默认浏览器配置：`Setting","link":"/posts/debugger-vue-in-webstorm"},{"title":"diff 最长递增子序列","tags":["diff 最长递增子序列"],"categories":["手写Vue3源码"],"author":"前端练习生zm","excerpt":"\n# diff\n## 全量 diff （重要）\n全量 diff 主要是针对两个子节点都是数组的情况，我们需要对它所有的子元素进行全量更新，那么这种更新非常消耗性能，\n在 vue 中会尝试着尽可能的复用","link":"/posts/diff"},{"title":"Vue3 中二次封装组件","tags":["二次封装组件"],"categories":["ZM 笔记"],"author":"前端练习生zm","excerpt":"\n## Vue3 中二次封装组件\n> 从二次封装 el-input 开始 🧀\n\n### 要解决的问题\n1. props 如何透传出去？\n2. slots 如何透传出去？\n3. 组件的方法如何暴露出去","link":"/posts/encapsulation-component"},{"title":"前端工程化-vite","tags":["前端工程化"],"categories":["ZM 笔记"],"author":"前端练习生zm","excerpt":"\n### 前端工程的痛点\n- 模块化需求\n- 兼容浏览器，编译高级语法\n- 线上代码的质量\n- 开发效率，项目的冷启动/二次启动时间、热更新时间\n\n### 前端构建工具是如何解决以上问题的呢？\n- 模","link":"/posts/engineering"},{"title":"替换有道图片外链","tags":["work-summary"],"categories":["work-summary"],"author":"前端练习生zm","excerpt":"\n#### 替换有道图片外链\n- 项目现在使用了有道的图片外链，后面可能导致图片无法显示，需要换成自己系统的\n- 在新增和编辑接口，将有道图片链接替换成自己的图片链接\n- 通过正则表达式匹配有道图片链","link":"/posts/external-link-replacement"},{"title":"git rebase","tags":["Git"],"categories":["Git"],"author":"前端练习生zm","excerpt":"\n## 关于 Git 变基\n`git rebase` 命令用于轻松更改一系列提交，修改存储库的历史记录。 可以进行重新排序、编辑提交或将提交压缩到一起。\n通常，你会使用 `git rebase`来：\n","link":"/posts/git-use"},{"title":"数马1","tags":["interview"],"categories":["interview"],"author":"前端练习生zm","excerpt":"\n## 数字马力面试题\n### 一面2025-07-18\n1. 自我介绍\n2. vue和react哪个熟悉\n3. 深浅拷贝区别，实现深拷贝有什么思路\n4. 对this的理解\n5. 改变this指向的方","link":"/posts/interview-szml"},{"title":"数马2","tags":["interview"],"categories":["interview"],"author":"前端练习生zm","excerpt":"\n## 数字马力二面 2025-07-28\n1. 自我介绍\n2. 下一家公司为什么不继续考虑杭州，而是考虑到长沙，现在薪资多少，了解长沙的薪资水平吗？\n3. 问项目是否是从0到1搭建的，参与制定git","link":"/posts/interview-szml-2"},{"title":"jeecg table 组件空数据时自定义内容","tags":["work-summary"],"categories":["work-summary"],"author":"前端练习生zm","excerpt":"\n#### jeecg table 组件空数据时自定义内容\n- 在使用 jeecg table 组件时，默认的空数据提示可能不符合需求，可以通过 `locale.emptyText` 属性自定义空数据","link":"/posts/jeecg-table-empty-custom-render"},{"title":"手写常见js代码","tags":["js手写"],"categories":["js手写"],"author":"前端练习生zm","excerpt":"\n### 模拟接口请求失败并实现递增间隔的重试机制\n请编写一个 JavaScript 函数 retryFetchWithDelay，模拟一个会失败的接口请求，并实现递增间隔的重试机制。具体要求如下：\n","link":"/posts/js-writing"},{"title":"大文件分片上传","tags":["nestjs"],"categories":["nestjs"],"author":"前端练习生zm","excerpt":"\n### 大文件上传介绍\n- 把大文件分成小文件，然后并行上传\n\n### **如何拆分和合并**\n- 通过 Blob的slice方法 对 File 分片,File是一种特殊的Blob\n- 合并：fs的","link":"/posts/nestjs"},{"title":"响应式","tags":["手写Vue3源码"],"categories":["手写Vue3源码"],"author":"前端练习生zm","excerpt":"\n# 响应式 —— Reactivity\nVue 的响应式系统核心在于响应式对象的属性与 effect 副作用函数之间建立的依赖关系。让我们通过具体示例来理解这个概念：\n- 普通函数访问响应式数据\n\n","link":"/posts/reactivity"},{"title":"git rebase合并多个commit","tags":["Git"],"categories":["Git"],"author":"前端练习生zm","excerpt":"\n## git rebase合并多个commit\n\n1. git rebase -i <想合并提交的前一个 commithash>\n2. git rebase -i HEAD~5 合并最近5个\n\n- ","link":"/posts/rebase"},{"title":"render 中的挂载、更新、卸载","tags":["render 中的挂载、更新、卸载"],"categories":["手写Vue3源码"],"author":"前端练习生zm","excerpt":"\n# render 中的挂载、更新、卸载\n## render 函数\n这个 `render` 跟我们组件中的 `render` 不是同一个 `render`，它是用来渲染根组件的\n`render` 函数","link":"/posts/render"},{"title":"核心运行时 —— runtime-core","tags":["核心运行时 —— runtime-core"],"categories":["手写Vue3源码"],"author":"前端练习生zm","excerpt":"\n# 核心运行时 —— runtime-core\n## 虚拟DOM如何创建？\n使用 `h` 和 `createVNode` 这两个函数来创建虚拟节点，那么既然都是创建虚拟节点，为什么还需要两个函数呢？","link":"/posts/runtime-core"},{"title":"浏览器运行时 —— runtime-dom","tags":["浏览器运行时 —— runtime-dom"],"categories":["手写Vue3源码"],"author":"前端练习生zm","excerpt":"\n# 浏览器运行时 —— runtime-dom\n## 虚拟 dom 的概念\n虚拟 DOM 其实就是用 js 对象来描述一个 DOM，Vue 最终会根据这个虚拟 DOM 创建出一个真实的 DOM 挂载","link":"/posts/runtime-dom"},{"title":"SSE原理","tags":["work-summary"],"categories":["work-summary"],"author":"前端练习生zm","excerpt":"\n\n服务器向浏览器推送信息，除了 `WebSocket`，还有一种方法：`Server-Sent Events`（以下简称 `SSE`）。\n![image.png](https://www.ruany","link":"/posts/sse"},{"title":"文本节点","tags":["文本节点"],"categories":["手写Vue3源码"],"author":"前端练习生zm","excerpt":"\n# 文本节点\n我们之前一直讲的是使用虚拟 DOM 创建某一个元素节点，渲染到页面中，其实 vue 还支持渲染文本节点，简单来说就是将一个文本节点渲染到真实 DOM 中，我们来看一下怎么使用的：\n``","link":"/posts/text-node"},{"title":"重学TypeScript","tags":["TypeScript"],"categories":["TypeScript"],"author":"前端练习生zm","excerpt":"\n```typescript\ninterface A {\n  [key: string]: string\n}\nconst foo: A = {\n  \"666\": '123',\n  11: \"xxx\",","link":"/posts/typescript"},{"title":"实现图片预加载 vite 插件","tags":["vite 插件"],"categories":["vite 插件"],"author":"前端练习生zm","excerpt":"\n\n## 实现图片预加载 vite 插件\n```ts\nexport default definConfig({\n  // base: '/dist/', // 如果项目部署在二级目录，需要指定 bas","link":"/posts/vite-plugin"},{"title":"手写 watch","tags":["手写 watch"],"categories":["手写Vue3源码"],"author":"前端练习生zm","excerpt":"\n## watch\n### 1. 利用 effect 实现watch的基本功能\n`watch` 的核心原理是利用 `ReactiveEffect` 来追踪响应式数据的变化，当然此处我们利用到了之前讲过","link":"/posts/watch"}]
